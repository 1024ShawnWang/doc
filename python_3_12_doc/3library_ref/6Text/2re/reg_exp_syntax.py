
'''
特殊字符。。。。。

1.  .   （点号），默认模式下，匹配除了换行符以为任意字符

2.  ^    （插入符），匹配字符串的开头

3.  $   匹配字符串尾，或者除去换行符的尾巴

4.  *   对它前面的正则表达式匹配 0-任意次重复, 贪婪匹配

5.  +   对比 *，这个匹配 1-inf次

6.  ?   对比+, 这个匹配 0-1次

7.  {m} 对之前的正则表达式指定匹配m个重复

8.  {m,n}   对比{m}，全闭区间，贪婪匹配

9.  {m,n}?  对比{m,n}, 恐惧匹配

10. \   转义特殊字符（ 转义，转回到原来的含义)

11. []  表示字符集合。

12. |   或

13. \number

14. \A

15. \b 只匹配空字符串

16. \B 对比\b，要求空字符串只能出现在字中（也即是说，开头和结尾的空字符串都不匹配)

17. \D 匹配不属于十进制数码的任意字符

18. \s 匹配空白字符 , unicode编码的话，包括 ntrfv

19. \S 匹配非空白字符，与18对立

20. \w 对于unicode编码，匹配所有单词类字符，包括unicode字符数类字符( str.isalnum()定义的，以及下划线

21. \W 和\w正好想法。两者的关系，应该类比 \s与 \S的关系

22. \Z  只匹配字符串尾
'''

#练习，如下字符串中，将所有字母（大小写26*2）匹配出来，并且打印

s='1324让3*23erd\nvsa-==dsf'

import re

reg =re.compile( '[0-9]+')
print( reg.match( s) )
#这次是匹配数字，注意看结果，解释是贪婪匹配，也只是匹配到了1324，后面的23是没有匹配出来的

reg1 =re.compile( '[a-z]+')
print( reg1.match(s))
#None，这是因为match只会从开头开始检测，search就不一样了

print( reg1.search(s))
#但是正则表达式对一个字符只会匹配一次，虽然是从左到右的任意位置

#注意到是三段字符串，所以将正则进一步增加
print( reg1.findall( s))  #注意对比 findall返回的是一个 List对象，对比match和search返回的match对象
final_reg = reg1.findall( s) #final_reg是个match对象
print(''.join( final_reg)) #注意 str.joint()用法

#还想把换行符也打印出来，那就使用原始字符
#如何将一个字符串变成原始字符串呢

#1? 如何 'abc' ---> "r'abc'"
#"r'abc'"是原始字符串吗？应该不是吧？那么还是原来的问题，如何将普通字符串转为原始字符串呢
